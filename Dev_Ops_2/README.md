# Очень плохой Docker файл

Для начала создадим Docker файл с "bad practices". В моём случае это указания `latest` тэга для базового образа, чрезмерно большое количество слоев и использование `ADD` заместо `COPY`.
## Код "плохого" контейнера
```
# Указываем lates для образа
FROM python:latest 

#используем сильно больше слоев чем нужно
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y vim
RUN apt-get install -y git

# Добавление вместо копирования
ADD . /app

# ещё слои
RUN pip install -r /app/requirements.txt

RUN useradd -m niroloks-user

USER niroloks-user

CMD ["python", "/app/main.py"]
```

## Описание плохих практик

### latest версия 
Ключевая проблема такого подхода заключается в том, что в данном случае мы по сути получаем кота в мешке. Не всегда новейшие версии обладают достаточной стабильностью, к тому же в некоторых ситуациях может понадобится весьма конкретная версия образа, тэг latest же не позволит выбрать необходимую версию

### Чрезмерно большое количество слоев
В данном случае всё упирается в оптимизацию, использование чрезмерно большого количества слоёв делает образ излишне тяжёлым, что может привести к уменьшению производительности.

### Использование `ADD` вместо `COPY`
Команда `ADD`, за имением некоторого количества дополнительных функций, является менее предсказуем, если задача состоит в простом копировании файлов, лучше всего использовать предназначенный для этого `СОР`.

# "Работа над ошибками"

Для начала представим исправленный Docker файл
## Код исправленного Docker файл
```
# Вместо lates указываем версию python 3.10.5
FROM python:3.10.5 

# Объединяем несколько команд на один слой и добавляем команду удаляющую временные файлы
RUN apt-get update && apt-get install -y \
    curl \
    vim \
    git \
    && rm -rf /var/lib/apt/lists/*

# не забываем заменить `ADD` на `COPY`
COPY . /app

# Объединяем установку зависимостей и очистку на один слой
RUN pip install --no-cache-dir -r /app/requirements.txt

RUN useradd -m niroloks-user

USER niroloks-user

CMD ["python", "/app/main.py"]
```
Теперь разберём, что конкретно мы исправили.

### Указываем точную версию образа

В исправленом примере вместо latest указываем точную версию (в нашем случае это `python:3.10.5`).

### Оптимизация использования слоёв

Вместо того чтобы устанавливать пакеты (`curl`, `vim`, `git`) на разных слоях, объединяем всё в один, тем самым уменьшить итоговый размер образа. Так же добавляем команду удаляющую временные файлы: `rm -rf /var/lib/apt/lists/*`.

### Используем `COPY` вместо `ADD`

Используем `COPY` вместо `ADD`, тем самым повышаем стабильность Docker файла.

# Плохие практики по работе с контейнерами

## Принебрижение к управлению логами
Если контейнер генерирует множество логов, без чётко прописанных инструкций, что может привести может повлиять как на стабильность работы контейнера, так и на работу системы в целом.
Для предотвращения таких проблем стоит запускать Docker файлы (как пример) следующим образом:
```
docker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 niroloks-app
```

## Запуск контейнеров без ограничений по ресурсам
По сути, этот пункт аналогичен предыдущему. В случае, если контейнер некоректно составлен, он может перегрузить CPU или RAM, что очевидно может превести к крайне неприятным исходам.
Для того чтобы не сталкнутся с такими проблемами стоит просто использовать простой советский...:

```
docker run --memory=512m --cpus=1 niroloks-app
```







