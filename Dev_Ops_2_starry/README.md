# Плохой Docker Compose файл
Для начала выполним первый пункт задания и приведём пример "плохого" Docker Compose файла
## Плохой Docker Compose в формате yaml
```
services:
  # Жёстко забинженные порты
  web:
    image: nginx:1.19
    ports:
      - "80:80"

  db:
    image: postgres:12
    environment:
      USER: user

      # Хранение sensetive данных в открытом виде
      NUCLEAR_PASSWORD: strong_password  # Пароль сохранён в открытом виде

  
  # Неограниченное использование ресурсов
  cache:
    image: redis:6
```
Теперт следует разобраться в ошибках

## Жёсткий бинд портов
Жётское указание портов может привести вызывать конфликты, если другой процесс пытается занять порт.
## Хранение sensetive информации в октрытом виде
Очевидно, что хранение важной и/или сектретной информации (в данном случае пароля) в открытом виде может быть небозопасным и повлечеть за собой утечки
## Неограниченное использование ресурсов
При отсутсвии ограничений на использование железа, внезапная ошибка может занять все ресурсы CPU и RAM, что может положить систему

# Хороший Docker Compose
Теперь приведём Docker Compose файл со всеми исправлениями
## Хороший Docker Compose в формате yaml
```
services:
  web:
    image: nginx:1.19
    # заменили жёсткую привязку, динамической привязкой на хосте
    ports:
      - "8080:80"  # Теперь внешний порт 8080 будет мапиться на внутренний порт 80, что уменьшает риск конфликтов

  db:
    image: postgres:12
    environment:
    USER: user
      
     # Для харения sensetive информации используем защищённые переменные
      NUCLEAR_PASSWORD: ${NUCLEAR_PASSWORD} 

    # Так же отдельно добавляем секреты
    secrets:
      - postgres_password

  cache:
    image: redis:6

    # Вводим ограничения на использование ресурсов 
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: 512M 

# Секреты секретики
secrets:
  postgres_password:
    file: ./secrets/postgres_password.txt

```

## Динамическая привязка на хосте
Вместо жётской привязке на порты, мы использовали динамическую привязку на хосте. Это позволяет уменьшить риск кофликтов
## Защищённые переменные вместо 
Теперь пароль хранится не в открытом виде, а в защищённой переменной, что повысит безопастность данных
## Ограничение на ресурсы
Введят ограничение на ресурсы мы обезопасили себя от внезапного слёта систме из-за перегрузки железа.

# Изоляция контейнеров
## Пример Docker Compose файла с сетевой изоляцией контейниров в формате yaml
```
services:
  web:
    image: nginx:1.19
    ports:
      - "8080:80"
    # Привязываем сервис к отдельной сети "web_network"
    networks:
      - web_network

  db:
    image: postgres:12
    environment:
      POSTGRES_USER: user
       NUCLEAR_PASSWORD: ${NUCLEAR_PASSWORD}
    secrets:
      - postgres_password
    # Привязываем сервис к отдельной сети "dataBASS_network"
    networks:
      - dataBASS_network

  cache:
    image: redis:6
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: 512M
    # Привязываем сервис к отдельной сети "cache_network"
    networks:
      - cache_network

# Определяем изолированные сети для каждого сервиса
networks:
  web_network:
    driver: bridge
 dataBASS_network:
    driver: bridge
  cache_network:
    driver: bridge

secrets:
  postgres_password:
    file: ./secrets/postgres_password.txt

```
Для достижения цели поставленной в лабараторной работе, необходимо привязать сети к каждому сервису. Для этого пропишем для каждого сервиса пропишем сеть, а затем определим их с помощью драйвера `bridge`.
В данном случае с помощью драйвера создаются виртуальные "частные" сети для каждого сервиса, тогда контейнеры в разных сетях не могут взаимодействовать друг с друг и остаются как бы "невидимымми"
